/*
    507. Perfect Number

    We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.

    Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.
    Example:
    Input: 28
    Output: True
    Explanation: 28 = 1 + 2 + 4 + 7 + 14
    Note: The input number n will not exceed 100,000,000. (1e8)

    Companies: Fallible
    Related Topics: Math
    Similar Questions: Self Dividing Numbers
 */

//Solution1: using hashset to avoid duplicate divisor, time O(√n)
class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num == 0)
            return false;
        Set<Integer> set = new HashSet();
        int res = 0;
        for (int i = 1; i <= (int)Math.sqrt(num); i++) {
            if (num % i == 0 && set.add(i) && set.add(num / i)) {
                res += i == 1 ? i : (num / i) + i;
                if (res > num)
                    return false;
            }
        }

        return res == num;
    }
}

//Solution2: use an more easy way to avoid duplicate, time O(√n)
class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num == 0 || num == 1)
            return false;
        int res = 0;
        for (int i = 2; i <= (int)Math.sqrt(num); i++) {
            if (num % i == 0) {
                res += i;
                if (i != num / i)
                    res += num / i;
            }
        }
        res++;
        return res == num;
    }
}

/*
    Euclid-Euler Theorem Algorithm
    Euclid proved that 2^p−1(2^p−1) is an even perfect number whenever 2^p−1 is prime, where p is prime.

    For example, the first four perfect numbers are generated by the formula 2^p−1(2^p−1), with p a prime number, as follows:

    for p = 2:   21(22 − 1) = 6
    for p = 3:   22(23 − 1) = 28
    for p = 5:   24(25 − 1) = 496
    for p = 7:   26(27 − 1) = 8128.
    Prime numbers of the form 2^p−1 are known as Mersenne primes. For 2^p−1 to be prime, it is necessary that p itself be prime.
    However, not all numbers of the form 2^p−1 with a prime pp are prime; for example, 211−1=2047=23×89 is not a prime number.

    You can see that for small value of p, its related perfect number goes very high.

    So, we need to evaluate perfect numbers for some primes (2, 3, 5, 7, 13, 17, 19, 31)(2,3,5,7,13,17,19,31) only, as for bigger prime its perfect number will not fit in 64 bits.
 */
//Solution3: time O(logn)
public class Solution {
    public int pn(int p) {
        return (1 << (p - 1)) * ((1 << p) - 1);
    }
    public boolean checkPerfectNumber(int num) {
        int[] primes=new int[]{2,3,5,7,13,17,19,31};
        for (int prime: primes) {
            if (pn(prime) == num)
                return true;
        }
        return false;
    }
}
